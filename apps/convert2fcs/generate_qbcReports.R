#!/usr/bin/env Rscript
library("optparse")
library("flowCore")
library("Biobase")
library("ggplot2")
library("gridExtra")
library("scales")

options(warn=-1)
## usage Rscript convert2fcs --fcsFile $forfcsfile --statsFile $statisticsFile

option_list = list(
  make_option( c("-fcs", "--fcsFile"), type = "character", default = NULL,
               help = "file containing tsv data", metavar = "character"),
  make_option(c("-stats", "--statsFile"), type = "character", default = NULL,
              help = "file containing statistics data for cuda-parse", metavar = "character"),
  make_option(c("-out", "--outFolder"), type = "character", default = NULL,
              help = "output folder path", metavar = "character")
)

opt_parser = OptionParser(option_list=option_list);
opt = parse_args(opt_parser);
if (is.null(opt$fcsFile) & is.null(opt$statsFile)){
  print_help(opt_parser)
  stop("At least one argument must be supplied (input file).n", call.=FALSE)
}

# read in ._forFCS file output from rmsinglets module
getFCSData <- function(filename_in) {
  if (!is.character(filename_in) || length(filename_in) != 1) 
    stop("'filename' must be character scalar")
  if (!file.exists(filename_in)) 
    stop(paste("'", filename_in, "' is not a valid file", sep = ""))
  
  x <- read.table(filename_in,sep="\t",header=TRUE,stringsAsFactors=FALSE)
  x[] <- lapply(x, as.numeric)
  return(x)
}

# read in the .statistics file output from cuda-parse
getStatsDat <- function(filename_in) {
  tmp <- read.csv(filename_in,header = FALSE,sep = '\t')
  tmp <- tmp[1:25,]
  tmp$V2 <- sapply(1:nrow(tmp),function(i) as.numeric(as.character(tmp$V2[i])))
  return(tmp)
}

# get the subcode counts found in the .statistics file output from cuda parse
getSubcodeDat <- function(filename_in) {
  tmp2 <- read.csv(filename_in,header=F,sep='\t',skip=40)   
  names(tmp2) <- c("subcodeId","subcodeSeq","counts")
  tmp2$codeGroup <- sapply(1:nrow(tmp2),function(i) strsplit(as.character(tmp2$subcodeId[i]),'_')[[1]][1])
  tmp2$codeNumber <- sapply(1:nrow(tmp2),function(i) as.numeric(strsplit(as.character(tmp2$subcodeId[i]),'_')[[1]][2]))
  return(tmp2)
}

# prepares and writes out a tsv file that is consumable by commercial 
# FCS analysis tools likeCytoBank and flowJo
tsv2fcs <- function(xData) {
  
  filename_out = paste(opt$outFolder, tools::file_path_sans_ext( basename( opt$fcsFile ) ), ".fcs", sep = "")

  if (colnames(xData)[1] == 'Barcode') {
    xData <- xData[, 2:ncol(xData)] #delete barcode column
  }
  
  #create event number column (can be used to trace back to barcode later)
  eventnum <- matrix(1:nrow(xData))
  xData <- cbind(eventnum, xData)
  colnames(xData)[1] <- "eventnum"
  
  #create fcs header
  params <- c()
  descrip <- list()
  
  descrip[["$DATATYPE"]] <- "F"
  descrip[["$MODE"]] <- "L"

  for (i in 1:ncol(xData)) {
    maxi <- max(xData[, i])
    rng <- maxi + 1
    
    pl <- matrix(c(colnames(xData)[i], colnames(xData)[i], rng, 0, maxi), nrow = 1)
    colnames(pl) <- c("name", "desc", "range", "minRange", "maxRange")
    rownames(pl) <- paste("$P", i, sep = "")
    params <- rbind(params, pl)
    
    descrip[[paste("$P", i, "B", sep = "")]] <- "32" # Number of bits
    descrip[[paste("$P", i, "R", sep = "")]] <- toString(rng) # Range
    descrip[[paste("$P", i, "E", sep = "")]] <- "0,0" # Exponent
    descrip[[paste("$P", i, "N", sep = "")]] <- colnames(xData)[i] # name
    descrip[[paste("$P", i, "S", sep = "")]] <- colnames(xData)[i] # name2
  }
  
  y <- flowFrame(as.matrix(xData), as(data.frame(params), "AnnotatedDataFrame"), description = descrip)

  print(paste("Creating file",filename_out,sep=" "))
  suppressWarnings(write.FCS(y, filename_out, "numeric"))
  
}

# a class to hold stats information generated by cuda-parse
setClass("qbcStats", slots=list(id="character", rawSeq="numeric", junkSeq="numeric",
                                smallAHCA="numeric",noAHCA="numeric",RCErrs="numeric", 
                                badSC1="numeric",badSC2="numeric",badSCN="numeric",
                                badSC3="numeric",nonOLbadSCs="numeric",xxxSC1="numeric",
                                xxxSC2="numeric",xxxSCN="numeric",xxxSC3="numeric",
                                tplMuts="numeric",tplNt="numeric"))

# Makes a dataframe for waterfall plot. Assumption here is that the statistics file from cuda parse  
# contains information for filtering reads that failed criteria
getWaterfall <- function(statsDat) {
  incDecrease <- statsDat@rawSeq
  n=1
  for (s in slotNames(statsDat)[3:15]) {
    tmp <- incDecrease[n]-slot(statsDat,s)
    incDecrease <- c(incDecrease,tmp)
    n <- n+1
  }
  tmp <- data.frame(step=c("raw",slotNames(statsDat)[3:15]), counts=incDecrease)
  return(tmp)
}

# customized axis scale transformation for fcs plotting since most events occur 
# at the low end and may contain negative values for point jittering purposes (this appears to be
# cell counting legacy practice that we're sticking with for now)
asinh_trans = function() trans_new("asinh", function(x) asinh(x), function(x) asinh(x))

# create a graph object of nxn matrix of paired marker correlation plots, where
# n = number of markers - 1
getFCSPlots <- function(fcsDat) { 
  markers = names(fcsDat)
  p <- list()
  for (i in 1:(length(markers)-1)) {
    mcor <- lapply((i+1):length(markers), function(ii) {
      subData <- fcsDat[,c(ii,i)]
      ggplot(data=subData,aes(x=subData[[1]],y=subData[[2]])) + geom_point(size=0.2,show.legend=FALSE,alpha=0.2) +
        geom_density_2d(contour=TRUE,colour='red') + 
        scale_x_continuous(trans = "asinh") + scale_y_continuous(trans = "asinh") +
        xlab(markers[[ii]])+ylab(markers[[i]])+
        theme(axis.text.x=element_blank(),axis.ticks.x = element_blank(),
              axis.text.y=element_blank(),axis.ticks.y = element_blank(),
              panel.grid.major = element_blank(), panel.grid.minor = element_blank())
    })
    p <- c(p,mcor)
  }
  return(p)
}

# Make waterfall plot of the reads surviving the filtering steps found in statistics file
# output from cuda-parse
waterfallPlot <- function(plotDat) {
  statsObj <- new("qbcStats",id="exp13",rawSeq=plotDat$V2[7],junkSeq=plotDat$V2[6],
                  smallAHCA=plotDat$V2[8],noAHCA=plotDat$V2[9],RCErrs=plotDat$V2[10],
                  badSC1=plotDat$V2[11],badSC2=plotDat$V2[12],badSCN=plotDat$V2[13],
                  badSC3=plotDat$V2[14],nonOLbadSCs=plotDat$V2[17],xxxSC1=plotDat$V2[18],
                  xxxSC2=plotDat$V2[19],xxxSCN=plotDat$V2[20],xxxSC3=plotDat$V2[21],
                  tplMuts=plotDat$V2[24],tplNt=plotDat$V2[25])
  df <- getWaterfall(statsObj)
  png(file=paste( opt$outFolder, "readWaterfall.png", sep="" ), bg="transparent",height=400,width=800)
  p <- ggplot(df,aes(x=step,y=counts))+geom_bar(stat='identity')+scale_x_discrete(limits=df$step)+
    theme(plot.title = element_text(size=rel(1.5),colour="blue"),
          axis.text.x = element_text(angle = 90,hjust=1),
          axis.title.x=element_text(size=rel(1.5)),axis.title.y = element_text(size=rel(1.5)))+
    labs(title="Surviving Reads",x="Filtered Step",y="Counts")
  show(p)
  dev.off()
}

# Make a bar plot of the counts per subcode, facet by parent subcode ID
subcodesPlot <- function(plotDat) {
  png(file=paste( opt$outFolder, "subcodeDistribution.png", sep="" ), bg="transparent",height=400,width=800)
  p <- ggplot(data=plotDat,aes(x=codeNumber,y=counts))+geom_bar(stat="identity")+
    facet_grid(codeGroup~.) +
    theme(plot.title = element_text(size=rel(1.5),colour="blue"),
          axis.text.x = element_text(angle = 90,hjust=1),
          axis.title.x=element_text(size=rel(1.5)),axis.title.y = element_text(size=rel(1.5)))+
    labs(title="Subcode Counts",x="Code Number",y="Counts")
  show(p)
  dev.off()
}

# Place the fcs matrix plot into a nxn grid and write out to a PNG file
#fcsGridPlot <- function(nMarkers,fcsGraphObj) {
#  
#  hlay <- sapply(1:nMarkers, function(i) { 
#    f <- (i-1)*nMarkers+1
#    e <- f+nMarkers-i
#    c(rep(NA,(i-1)),f:e)
#  })
#  
#  png(file=paste( opt$outFolder, "fcsPlots.png", sep="" ), bg="transparent",height=4000,width=4000)
#  grid.arrange(grobs=fcsGraphObj,ncol=nMarkers,nrow=nMarkers,layout_matrix=t(hlay))
#  dev.off()
#}

# process and make plots for FCS data if a file is provided
if (!is.null(opt$fcsFile)) {
  fcsData <- getFCSData(opt$fcsFile)
  tsv2fcs(fcsData)
#  fcsObj <- getFCSPlots(fcsData)
#  nMarkers <- length(names(fcsData))-1
#  fcsGridPlot(nMarkers,fcsObj)
}

# Process and make plots if a statistics file is provided
if (!is.null(opt$statsFile)) {
  statsDat <- getStatsDat(opt$statsFile)
  waterfallPlot(statsDat)
  subcodesDat <- getSubcodeDat(opt$statsFile)
  subcodesPlot(subcodesDat)
}

